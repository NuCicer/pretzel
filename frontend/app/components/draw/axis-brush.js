import { computed } from '@ember/object';
import { alias } from '@ember/object/computed';
import Evented from '@ember/object/evented';
import { on } from '@ember/object/evented';
import Component from '@ember/component';
import { inject as service } from '@ember/service';
import { throttle, debounce } from '@ember/runloop';
import DS from 'ember-data';


import PathData from './path-data';

import AxisEvents from '../../utils/draw/axis-events';
import { stacks, Stacked } from '../../utils/stacks';
import {
  selectAxis,
  blockAdjKeyFn,
  blockAdjEltId,
  featureEltIdPrefix,
  featureNameClass,
  foregroundSelector,
  selectBlockAdj
} from '../../utils/draw/stacksAxes';

/* global d3 */

/*----------------------------------------------------------------------------*/

/** Used for CSS selectors targeting <g> and <path>-s generated by this component. */
const className = "axisBrush";
const CompName = 'components/axis-brush';

const trace_axisBrush = 1;
const dLog = console.debug;


/*----------------------------------------------------------------------------*/

/**
 * @param blockId
 * @param drawMap for Evented - stack events
 */
export default Component.extend(Evented, AxisEvents, {
  /** AxisEvents is used to receive axis stacking and resize events.
   *  Evented may be used in future to propagate events to components rendered within axis-brush.
   */
  store: service(),
  pathsP : service('data/paths-progressive'),

  /*--------------------------------------------------------------------------*/

  stacks : stacks,
  oa : alias('stacks.oa'),
  /** .drawMap is used by Evented : utils/draw/axis-events.js */
  drawMap : alias('oa.eventBus'),
  axisApi : alias('oa.axisApi'),

  /*--------------------------------------------------------------------------*/

  tagName : '',

  zoomCounter : 0,

  /*--------------------------------------------------------------------------*/

  datasetName : computed('block', 'id', function () {
    let
    axis = this.get('axis'),
    name = axis && axis.axis1d && axis.axis1d.get('referenceBlock.datasetId.id');
    dLog('datasetName', name, axis);
    return name;
  }),


  brushedDomainRounded : computed('block.brushedDomain', function () {
    let domain = this.get('block.brushedDomain');
    if (domain) {
      domain = domain.map((d) => d.toFixed(2));
    }
    return domain;
  }),

  /*--------------------------------------------------------------------------*/

  axisBrush : computed('block', function () {
    let
      block = this.get('block'),
    /** axis-brush object in store */
    record = this.get('pathsP').ensureAxisBrush(block);
    if (trace_axisBrush)
      dLog('block', block.id, block, record);
    return record;
  }),

  blockId : alias('block.id'),

  /** Result is, for blockID,  the axis on which the block is displayed.
   * Will need to add dependency on stacks component, because block can be un-viewed then re-viewed.
   */
  axis :  computed('blockId', function () {
    let
      blockId = this.get('blockId'),
    axis = Stacked.getAxis(blockId);
    console.log('axis', axis);
    return axis;
  }),

  features : computed('axisBrush.features.[]', 'zoomCounter', function () {
    console.log('features', this);
    let featuresP = this.get('axisBrush.features');
    featuresP.then((features) => {
    if (features && features.length)
      throttle(this, () => ! this.isDestroying && this.draw(features), 200, false);
    });
    return featuresP;
  }),

  /*--------------------------------------------------------------------------*/

  featuresReceived : undefined,

  initData : on('init', function () {
    this.set('featuresReceived', {});
  }),

  /** Augment axis1d.brushedBlocks with features.length and block
   * .featuresCountIncludingZoom (later : featuresCountInBrush)
   */
  brushedBlocks : computed(
    'axis.axis1d.brushedBlocks.[]',
    'block.brushedDomain.{0,1}',
    'axisBrush.features.{isFinished,value}',
    function () {
      let
      blocks = this.get('axis.axis1d.brushedBlocks') || [],
      featuresP = this.get('axisBrush.features'),
      brushedBlocks = blocks.map((block, i) => {
        let 
        featuresCount = block.get('featuresCountIncludingZoom'),
        featuresLengthP = featuresP.then((results) => {
          let featuresLengthResult = results[i],
              length =  featuresLengthResult && featuresLengthResult.value.length;
          if (featuresLengthResult) {
            this.featuresReceived[block.id] = length;
          }
          return length;
        }),
        featuresLengthPO = DS.PromiseObject.create({ promise: featuresLengthP });

        // 1 decimal place.
        if (featuresCount) {
          featuresCount = Math.round(featuresCount * 10) / 10;
        }
        return {featuresLengthPO, block, featuresCount};
      });
      featuresP.then((results) => dLog('brushedBlocks results', results));
      dLog('brushedBlocks', brushedBlocks);
      return brushedBlocks;
    }),

  /*--------------------------------------------------------------------------*/

  isAxis(axisID) {
    let axis = this.get('axis'),
    match = (axis.axisName === axisID);
    return match;
  },

  /*--------------------------------------------------------------------------*/


  /**
   * @param features
   */
  draw (features) {
    if (features.length === 0)
      return;

    let axisApi = this.get('axisApi');
    dLog('draw', this, features.length, axisApi);
    if (axisApi) {
      let
        /** defined after first brushHelper() call. */
        axisFeatureCirclesBrushed = axisApi.axisFeatureCirclesBrushed;
      if (axisFeatureCirclesBrushed)
        axisFeatureCirclesBrushed();
    }

  },

  /** Update the cx and cy attributes of the <circle>-s.  */
  updateFeaturesPosition() {
  },

  /*--------------------------------------------------------------------------*/

  updateFeaturesPositionDebounce(axisID_t) {
    // console.log('updateFeaturesPositionDebounce', axisID_t);
    debounce(this, this.updateFeaturesPosition, axisID_t, 500);
  },

  /*--------------------------------------------------------------------------*/
  
  /** axis-brush receives axisStackChanged and zoomedAxis from draw-map
   */

  resized : function(widthChanged, heightChanged, useTransition) {
    if (trace_axisBrush > 1)
      dLog("resized in ", CompName);
    if (heightChanged)
      // instead of debounce, can trigger position update with this.incrementProperty('rangeCounter');
      this.updateFeaturesPositionDebounce();
  },

  axisStackChanged : function() {
    if (trace_axisBrush > 1)
      dLog("axisStackChanged in ", CompName);
    this.updateFeaturesPositionDebounce();
  },

  /** @param [axisID, t] */
  zoomedAxis : function(axisID_t) {
    let axisID = axisID_t[0],
    blockId = this.get('blockId'),
    axis = this.get('axis');
    if (trace_axisBrush > 1)
      console.log("zoomedAxis in ", CompName, axisID_t, blockId, axis);
    if (this.isAxis(axisID))
    {
      if (trace_axisBrush > 1)
        dLog('zoomedAxis matched', axisID, blockId, axis);
      this.incrementProperty('zoomCounter');
    }
  }
  /*--------------------------------------------------------------------------*/

  
});


/*----------------------------------------------------------------------------*/

function featureEltId(featureBlock)
{
  let id = featureKeyFn(featureBlock);
  id = featureNameClass(id);
  return id;
}


function featureKeyFn (featureBlock)
{ return featureBlock._id.name; }



/*----------------------------------------------------------------------------*/
